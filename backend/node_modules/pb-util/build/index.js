"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const toString = Object.prototype.toString;
const encoders = {
    [typeOf({})]: v => wrap('structValue', exports.struct.encode(v)),
    [typeOf([])]: v => wrap('listValue', exports.list.encode(v)),
    [typeOf(0)]: v => wrap('numberValue', v),
    [typeOf('')]: v => wrap('stringValue', v),
    [typeOf(true)]: v => wrap('boolValue', v),
    [typeOf(null)]: () => wrap('nullValue', 0)
};
function typeOf(value) {
    return toString.call(value);
}
function wrap(kind, value) {
    return { kind, [kind]: value };
}
/**
 * Used to encode/decode {@link Value} objects.
 */
exports.value = {
    /**
     * Encodes a JSON value into a protobuf {@link Value}.
     *
     * @param {*} value The JSON value.
     * @returns {Value}
     */
    encode(value) {
        const type = typeOf(value);
        const encoder = encoders[type];
        if (typeof encoder !== 'function') {
            throw new TypeError(`Unable to infer type for "${value}".`);
        }
        return encoder(value);
    },
    /**
     * Decodes a protobuf {@link Value} into a JSON value.
     *
     * @param {Value} value the protobuf value.
     * @returns {*}
     */
    decode(value) {
        switch (value.kind) {
            case 'listValue':
                return exports.list.decode(value.listValue);
            case 'structValue':
                return exports.struct.decode(value.structValue);
            case 'nullValue':
                return null;
            default:
                return value[value.kind];
        }
    }
};
/**
 * Used to encode/decode {@link Struct} objects.
 */
exports.struct = {
    /**
     * Encodes a JSON object into a protobuf {@link Struct}.
     *
     * @param {Object.<string, *>} value the JSON object.
     * @returns {Struct}
     */
    encode(json) {
        const fields = {};
        Object.keys(json).forEach(key => {
            // If value is undefined, do not encode it.
            if (typeof json[key] === 'undefined')
                return;
            fields[key] = exports.value.encode(json[key]);
        });
        return { fields };
    },
    /**
     * Decodes a protobuf {@link Struct} into a JSON object.
     *
     * @param {Struct} struct the protobuf struct.
     * @returns {Object.<string, *>}
     */
    decode({ fields }) {
        const json = {};
        Object.keys(fields).forEach(key => {
            json[key] = exports.value.decode(fields[key]);
        });
        return json;
    }
};
/**
 * Used to encode/decode {@link ListValue} objects.
 */
exports.list = {
    /**
     * Encodes an array of JSON values into a protobuf {@link ListValue}.
     *
     * @param {Array.<*>} values the JSON values.
     * @returns {ListValue}
     */
    encode(values) {
        return {
            values: values.map(exports.value.encode)
        };
    },
    /**
     * Decodes a protobuf {@link ListValue} into an array of JSON values.
     *
     * @param {ListValue} list the protobuf list value.
     * @returns {Array.<*>}
     */
    decode({ values }) {
        return values.map(exports.value.decode);
    }
};
//# sourceMappingURL=index.js.map